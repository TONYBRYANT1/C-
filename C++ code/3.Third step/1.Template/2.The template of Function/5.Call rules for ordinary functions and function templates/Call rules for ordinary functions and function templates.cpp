//普通函数与函数模版的调用规则
//调用规则如下:
//1.如果函数模版和普通函数都可以实现,优先调用普通函数
//2.可以通过空模版参数列表来强制调用函数模版
//3.函数模版可以发生重载
//4.如果函数模版可以产生更好的匹配,优先调用函数模版

//总结:既然提供了函数模版,最好就不要提供普通函数,否则容易出现二义性

#include<bits/stdc++.h>
using namespace std;

//1.如果函数模版和普通函数都可以实现,优先调用普通函数
void myPrint(int a , int b)
{
    cout << "普通函数的调用" << endl;
}

template<typename T>
void myPrint(T a , T b)
{
    cout << "函数模版的调用" << endl;
}

template<typename T>
void myPrint(T a , T b , T c)
{
    cout << "重载的函数模版的调用" << endl;
}

//1.如果函数模版和普通函数都可以实现,优先调用普通函数
void test01()
{
    int a = 0;
    int b = 0;
    myPrint(a,b);
}

//2.可以通过空模版参数列表来强制调用函数模版
void test02()
{
    int a = 0;
    int b = 0;
    myPrint<>(a,b);
}

//3.函数模版可以发生重载
void test03()
{
    int a = 0;
    int b = 0;
    int c = 0;
    myPrint<>(a,b);
    myPrint<>(a,b,c);
}

//4.如果函数模版可以产生更好的匹配,优先调用函数模版
void test04()
{
    char a = 'a';
    char b = 'b';
    int c = 10;
    myPrint(a,b);//调用函数模版(自动类型推导)
    myPrint(a,c);//调用普通函数(如果函数模版采用自动类型推导,就不会发生隐式类型转换)
    myPrint<int>(a,c);//调用函数模版(如果显示指定类型的方式,可以发生隐式类型转换)
}


int main()
{
    //1.如果函数模版和普通函数都可以实现,优先调用普通函数
    //(如果普通函数和函数模版均有实现:
    //1.如果普通函数有实现,优先调用普通函数 
    //2.如果普通函数没有实现,也会优先调用普通函数,由于没有具体实现,所以会报错)
    //test01();

    //2.可以通过空模版参数列表来强制调用函数模版
    //test02();

    //3.函数模版可以发生重载
    //test03();

    //4.如果函数模版可以产生更好的匹配,优先调用函数模版
    test04();
    //编译器思路:1.走普通函数---自动类型转换(隐式类型转换)
    //          2.走函数模版---自动类型推导
    //所以:走函数模版更加方便

    return 0;
}